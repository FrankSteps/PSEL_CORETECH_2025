% Preâmbulo

\documentclass[a4paper]{article} % A4, o padrão usado no Brasil.
\usepackage[brazilian]{babel} % Linguagem em português.
\usepackage{abnt} % Normas ABNT.
\usepackage[utf8]{inputenc} % UTF-8.
\usepackage[T1]{fontenc} % Permite fontes com mais glifos (letras).
% Fonte bonita que é usada até hoje.
% Veja: <https://tex.stackexchange.com/questions/147194/is-it-still-useful-to-load-the-lmodern-package>
\usepackage{lmodern}
\usepackage{amsmath, amsthm, amssymb} % Coisas de matemática.
\usepackage[table, xcdraw]{xcolor} % Definições fáceis de cor.
\usepackage[hyphens]{url} % Links.
\usepackage{bookmark} % Permite links fáceis entre múltiplos arquivos.
\usepackage{hyperref} % Referências.
\definecolor{bblue}{HTML}{0645AD} % Azul meio escuro.
\hypersetup{colorlinks, linkcolor=blue, urlcolor=bblue} % Links azuis.
% Subindo o título.
\usepackage{titling} % Informações de títulos melhores.
\setlength{\droptitle}{-6em}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}
\usepackage[stretch=10]{microtype} % Ajuste de espaçamento.
\usepackage{hyphenat} % Configuração de hífens.
\usepackage{ragged2e} % Mais comandos de hífens.
\usepackage{listings} % Cores pra código.
\usepackage[explicit]{titlesec} % Estilos de título.
\usepackage{fvextra} % Melhorias para blocos de código.
\usepackage{tcolorbox} % Caixas legais que podem ser usadas para colocar código dentro.
\usepackage{calc} % Matemática em comandos.
\usepackage{hyperref} % Comando para adicionar links no documento
\hypersetup {
  pdfauthor={Grupo 1},
  pdftitle={Problema C: Implementação de um interpretador feito em C para a arquitetura PicoQuickProcessor},
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={TeX Live 2025},
  pdflang={English}
}

% Identificação.

\author{Grupo 1}
\date{\today}
\title{Problema C: Implementação de um interpretador feito em C para a arquitetura PicoQuickProcessor}

% Documento.

\makeatother
\begin{document}

\maketitle

\tableofcontents

\pagebreak

\section{Membros}

\begin{center}
  \begin{tabular}{ll}
    Nome & Curso\\
    \hline
    Francisco Passos dos Santos Alves & Ciência da Computação\\
    Gabriel Santos de Souza & Engenharia da Computação\\
    Guilherme Ferreira Amâncio & Ciência da Computação\\
    Rhuan Pablo Silva Santos & Engenharia da Computação\\
    João Vinícius de Almeida Argolô & Engenharia da Computação\\
  \end{tabular}
\end{center}

\section{Introdução}

Esta documentação refere-se ao ``Problema C'' da documentação disponibilizada pela equipe da CORETECH para o processo seletivo (PSEL) a qual os membros responsáveis por este projeto estão participando.

O objetivo do projeto a qual este arquivo irá documentar --- assim como foi pedido na documentação do PSEL da coretech --- é criar um simulador, em linguagem C/C++, capaz de reproduzir o comportamento de um processador 32 Bits como artifício para didática. Essa simulação será executada em um ambiente x86-64 e um arquivo contendo um código de máquina será oferecida como a entrada e, por intermédio do simulador projetado conforme as regras de arquitetura d o PicoQuick, gerará um relatório detalhado da execução e do estado final do sistema.

Esta documentação contará com informações técnicas valiosas de como cada átimo deste projeto funciona e assim servindo como material de apoio técnico-didático para disciplinas como arquitetura de computadores e sistemas operacionais.

\section{Estruturas de Dados}

O projeto está organizado de uma maneira semelhante ao paradigma orientado a objetos, utilizando de \texttt{structs} para isso. Como legenda, saiba que, para todo campo de um \texttt{struct} que foi citado, em parênteses estará seu tipo.

\subsection{Memória}

Para a memória, um \texttt{struct} contendo múltiplos campos foi utilizado:

\begin{enumerate}
\item \texttt{mem8} (\texttt{uint8\_t})
  \begin{description}
  \item Representa um byte de memória.
  \end{description}
\item \texttt{size} (\texttt{uint32\_t})
  \begin{description}
  \item Indica o tamanho atual da instância de memória. Usado para inicialização, com um valor personalizado.
  \end{description}
\item \texttt{loaded} (\texttt{bool})
  \begin{description}
  \item Indica se esta instância de memória foi carregada.
  \end{description}
\end{enumerate}

\subsubsection{Funções}

Os tipos \texttt{uint} utilizados vem do header \texttt{<stdint.h>}, e portanto possuem larguras fixas, independentemente da implementação.

Funções que acompanham esse \texttt{struct} são:

\begin{itemize}
\item \texttt{mem\_create} (\texttt{Memory*})
  \begin{description}
  \item Cria uma nova instância de memória. Recebe como argumento \texttt{size}, alocando quantidade de memória indicado por ele, com alinhamento de 1 byte.
  \end{description}
\item \texttt{mem\_destroy} (\texttt{void})
  \begin{description}
  \item \textit{Wrapper} para a função \texttt{free}.
  \end{description}
\item \texttt{mem\_load\_program} (\texttt{void})
  \begin{description}
  \item Dada uma instância de memória \texttt{mem} e um caminho de diretório \texttt{input\_path}, essa função carrega o arquivo na memória.
  \end{description}
\item \texttt{mem\_read8} (\texttt{uint16\_t})
  \begin{description}
  \item Lê um byte de memória.
  \end{description}
\item \texttt{mem\_read32} (\texttt{uint32\_t})
  \begin{description}
  \item Lê quatro bytes de memória.
  \end{description}
\end{itemize}

\subsection{Registradores}

Os registradores não estão organizados numa forma específica para eles. Todavia, fazem parte do \texttt{struct} \texttt{Cpu}, que guarda as seguintes informações:

\begin{enumerate}
\item \texttt{pc} (\texttt{uint16\_t})
  \begin{description}
  \item Indica a quantidade de programas (instruções) que o interpretador está a processar.
  \end{description}
\item \texttt{r[REG\_COUNT]} (\texttt{uint32\_t})
  \begin{description}
  \item Cria um \texttt{array} que servirá para simular os 16 registradores de propósito geral da arquitetura.
  \end{description}
\end{enumerate}

Um dos campos foi omitido, mas ele será logo explicado.

\subsection{Flags}

As \texttt{flags}, assim como os registradores, fazem parte da definição da CPU.

Elas são manipuladas pela função \texttt{update\_flags}. Como exigido pelo documento, as flags são \texttt{L} (\textit{Less}), \texttt{E} (\textit{Equal}) e \texttt{G} (\textit{Greater}).

\section{Lógica Principal}

Um \texttt{while} loop é usado para fazer o programa rodar até o fim do arquivo. Nele, é executado a função \texttt{cpu\_cycle}. Ela traduz código de máquina guardado na memória em instruções e as executa. A função incrementa o campo \texttt{pc} em 4 pois as instruções estão separadas em blocos de quatro sequências hexadecimais. Essa é a função principal do projeto, então vamos se aprofundar nela.

Prosseguindo com a função, o código de máquina é lido com a função \texttt{fetch}. Durante a leitura, a execução é pausada, e instruções são armazenadas na memória, de quatro em quatro bytes. \textit{Big endian} é usado para carregamento, e \textit{little} para a leitura. Para contribuir para o \textit{logging}, a função contém um print que escreve a instrução (de \texttt{fetch}).

Outro componente importante é a função \texttt{decode}, usada para traduzir o código de máquina carregado pelo \texttt{fetch} em instruções claras para o interpretador. Após receber código de máquina, ela pega os 8 bits mais significativos e depois dá um shift pra direita por 24 para eliminar os zeros. E, assim como \texttt{fetch}, o \textit{logging} faz parte da própria função.

Por fim, a \texttt{execute} recebe a instrução decodificada e a relaciona com uma tabela de instruções (um \texttt{array}). A ideia de Vinícius aqui era de implementar o \texttt{execute} de uma forma que ele tivesse tempo $O_{(1)}$ (constante), mas o interessante é que o compilador já faz isso com \texttt{switches}.

\section{Desafios}
	O principal desafio foi o tempo. O projeto demandou muito esforço e agilidade para o seu planejamento, execução, direção e documentação. Além deste, para tornar o projeto mais didático e mais auto-explicativo, foi necessário um amplo conhecimento e experiência na linguagem C, arquitetura de computadores e sistemas operacionais. Aplicações como: arquitetura, design do código pra otimização e organização e a desenvoltura do modulo foram um dos principais desafios como mencionou Vinícius.
	Os contra-tempos não se voltaram apenas ao projeto, como também à liderança do grupo para que o mesmo fosse o mais produtivo possível.  


\section{Decisões}

A primeira decisão, introduzida por Francisco Passos e aceita pelo grupo, consistiu na subdivisão da liderança, de modo que aquele que se destacasse em determinada parte do projeto seria o responsável por ditar as diretrizes de organização e/ou planejamento dentro de seu setor de atuação. Com esse princípio em mente, Gabriel ficou responsável pela liderança da documentação do projeto, visto que já possuía experiência com LaTeX. Vinícius, por sua vez, assumiu a liderança da execução prática do projeto, por ser o membro mais “mão na massa” e já possuir uma experiência acadêmica maior que os demais. Por fim, Francisco ficou encarregado por gerenciar o repositório no GitHub, mantendo-se como chefe de equipe e responsável por acompanhar o desenvolvimento geral do projeto tanto do software, como da documentação. 

A segunda decisão foi a escolha pela resolução do Problema C. O principal motivo foi o fato de que todos os integrantes do grupo já possuíam experiência com a linguagem C, o que tornava o Problema C a escolha mais conveniente para o bom andamento do projeto. Mesmo que algum membro não atuasse diretamente no simulador, teria ainda assim a capacidade de compreender as etapas de sua construção.

Por fim, a terceira e última decisão, tomada por Vinícius — líder da execução do projeto —, dizia respeito à organização do código em C do pqp-interpreter. A estrutura do código foi elaborada de forma a ser o mais didática possível, com o desenvolvimento dividido em etapas bem definidas, o que contribuiu significativamente para a legibilidade e manutenção do projeto. Essa decisão representou um dos maiores desafios enfrentados, conforme mencionado na seção de desafios.


\section{Aprendizado como uma unidade}

O grupo uniu-se sob a filosofia de pensar como uma unidade. Cada integrante contribuiu com o que pôde, utilizando os artifícios que possuía. O objetivo não foi buscar o melhor resultado absoluto, mas sim realizar o necessário com as condições disponíveis — o essencial. Os participantes que aceitaram o desafio empenharam-se para alcançar o melhor resultado possível, tanto para si quanto para o grupo.

\begin{quote}
“Adam Smith disse que a melhoria individual servia à conquista do grupo.  
Mas isso é incompleto. O melhor resultado ocorre quando todos no grupo fazem o que é melhor para si e para o grupo.”
\end{quote}
\hfill \textit{John Nash, ganhador do prêmio Nobel de economia em 1994}


\section{Repositório do projeto no GitHub}

O código-fonte e demais arquivos do projeto estão disponíveis publicamente no seguinte repositório:

\begin{center}
\url{https://github.com/FrankSteps/PSEL_CORETECH_2025}
\end{center}


\section{Referências}

(JAKE BOX (ED.). \textbf{Perfect Emacs Org Mode Exports to LaTeX – Straightforward Emacs}. 7 Mar. 2021. Disponível em: <\url{https://www.youtube.com/watch?v=0qHloGTT8XE}>. Acesso em: 13 nov. 2024)

\end{document}
