Para facilitar a leitura

Primeira instrução: mov rx, i16 -- significado: rx = i16 (move um valor imediato de 16 bits p/o registrador rx)
Segunda instrução: mov rx, ry -- significado: rx = ry (copia o valor do registrador ry p/o registrador rx)
Terceira instrução: mov rx, [ry] -- significado: rx = MEM[ry] (carrega o valor da memória, endereçada por ry, para o registrador rx)
Quarta instrução: mov [rx], ry -- significado: MEM[rx] = ry (armazena o valor de ry na posição de memória endereçada por rx)
Quinta instrução: cmp rx, ry -- significado: rx <-> ry (compara os valores dos registradores rx e ry)
Sexta instrução: jmp i16 -- significado: (Salto incondicional: O PC é atualizado para o endereço atual + 4 + o valor imediato de i16)
Sétima instrução: jg i16 -- significado: (Salto condicional: se o flag ">g" for 1, o PC é atualizado para...)
Oitava instrução: jl i16 -- significado: (Salto condicional: se o flag "<l" for 1, o PC é atualizado para...)
Nona instrução: je i16 -- significado: (Salto condicional: se o flag "=" for 0, ou seja, os valores serem diferentes, o PC é atualizado...)
Décima instrução: add rx, ry -- significado: rx += ry (soma o valor de ry ao valor de rx e armazena em rx)
Décima primeira instrução: sub rx, ry -- significado: (subtrai o valor de ry do valor de rx e armazena em rx)
Décima segunda instrução: and rx, ry -- signficado: (operação lógica "E" bit a bit entre rx e ry e armazena o resultado em rx)
Décima terceira instrução: or rx, ry -- significado: (..."OU" bit a bit...)
Décima quarta instrução: xor rx, ry -- significado: (.."XOR" bit a bit...)
Décima quinta instrução: sal rx, i15 -- significado: (move os bits de rx p/a esquerda pelo num de posições especificado por i5)
Décima sexta instrução: sar rx, i5 -- significado: (move os bits de rx p/a a direita...)
